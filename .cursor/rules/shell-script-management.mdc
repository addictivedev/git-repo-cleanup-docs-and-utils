---
alwaysApply: true
description: Prevent proliferation of shell scripts and enforce BATS testing
---

# Shell Script Management and Testing Rules

## Avoid Proliferation of .sh Files

**NEVER create external `.sh` script files** unless absolutely necessary. Instead:

### ‚úÖ Preferred Approaches:
1. **Fix existing functions** in [clean-large-blobs.sh](mdc:clean-large-blobs.sh) or [clean-secrets.sh](mdc:clean-secrets.sh)
2. **Use the existing justfile** task runner: [justfile](mdc:justfile)
3. **Integrate functionality** into existing scripts rather than creating new ones
4. **Use BATS tests** for verification and testing: [tests/bats/](mdc:tests/bats/)

### ‚ùå Avoid Creating:
- `verify-*.sh` scripts
- `test-*.sh` scripts  
- `check-*.sh` scripts
- Any standalone `.sh` files

### üîß When External Scripts Are Needed:
Only create external `.sh` files if:
- They are **core functionality** (like [clean-large-blobs.sh](mdc:clean-large-blobs.sh))
- They are **deployment scripts** (like [deploy.sh](mdc:deploy.sh))
- They are **part of the main project workflow**

## Enforce BATS Testing

**ALWAYS use BATS tests** for verification and testing:

### ‚úÖ Use BATS Tests For:
- **Verification logic**: Use [tests/bats/test_clean_large_blobs.bats](mdc:tests/bats/test_clean_large_blobs.bats)
- **Secret cleanup testing**: Use [tests/bats/test_clean_secrets.bats](mdc:tests/bats/test_clean_secrets.bats)
- **Debugging and analysis**: Use [tests/bats/debug-gitleaks.bats](mdc:tests/bats/debug-gitleaks.bats)
- **Helper functions**: Use [tests/bats/helpers/setup.bash](mdc:tests/bats/helpers/setup.bash)

### üéØ BATS Test Structure:
```bash
# Use the existing test framework
@test "test description" {
    # Test implementation
    run ./clean-large-blobs.sh
    [ "$status" -eq 0 ]
}
```

### üìÅ Test Organization:
- **Main tests**: [tests/bats/](mdc:tests/bats/) directory
- **Test fixtures**: [tests/fixtures/](mdc:tests/fixtures/) directory
- **Helper functions**: [tests/bats/helpers/setup.bash](mdc:tests/bats/helpers/setup.bash)

## Integration with Project Tools

### Use Existing Project Structure:
- **Task runner**: [justfile](mdc:justfile) for common operations
- **Core scripts**: [clean-large-blobs.sh](mdc:clean-large-blobs.sh), [clean-secrets.sh](mdc:clean-secrets.sh)
- **Python callbacks**: [clean-secrets-callbacks/](mdc:clean-secrets-callbacks/) for complex logic
- **Configuration**: [config.js](mdc:config.js), [settings.py](mdc:settings.py)

### üîÑ Workflow Integration:
1. **Modify existing functions** instead of creating new scripts
2. **Add BATS tests** for new functionality
3. **Update justfile** for new tasks
4. **Use existing verification** functions in core scripts

## Examples of Good vs Bad Practices

### ‚ùå Bad: Creating External Scripts
```bash
# DON'T DO THIS
verify-cleanup-success.sh
test-repository.sh
check-files.sh
```

### ‚úÖ Good: Using Existing Infrastructure
```bash
# DO THIS INSTEAD
# Fix verify_repository_content() in clean-large-blobs.sh
# Add tests to tests/bats/test_clean_large_blobs.bats
# Add tasks to justfile
```

## Project-Specific Context

This project focuses on **Git repository migration and security** using:
- **git-filter-repo** for history rewriting
- **gitleaks** for secret detection
- **BATS** for testing and verification

The project already has a well-structured approach - **enhance it rather than creating parallel systems**.

## Enforcement

When suggesting changes:
1. **First check** if functionality exists in existing scripts
2. **Modify existing functions** rather than creating new files
3. **Write BATS tests** for any new functionality
4. **Update justfile** for new tasks
5. **Only create external scripts** as a last resort for core functionality